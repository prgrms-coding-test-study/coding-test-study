## 👤 작성자
김지수

---

## 🧩 문제 정보
<!-- [문제 제목](문제 링크) 형식으로 작성하세요 -->
[여행 경로](https://school.programmers.co.kr/tryouts/198625/challenges)

---

## 💭 아이디어
- 재귀 함수 기반 백트래킹 활용
- 아직 사용한 적이 없고, 출발지가 `curr`인 티켓을 사용한 뒤 현재 경로 `route`에 티켓의 도착지 추가
- 현재 경로 `route`가 최적 경로 `answer`를 알파벳 순서로 절대 앞설 수 없으면 `early return`

---

## 🧑‍💻 코드
<!-- 작성한 코드를 백틱으로 감싸 넣어주세요 --> 
```python
from copy import deepcopy

### 대문자 아스키 코드 값 < 소문자 아스키 코드 값
### useTicket()에서 answer와 route 최초 비교 시 항상 answer > return 만족
START = "ICN"
DUMMY = START.lower()

SRC = 0
DEST = 1

answer = [DUMMY]
route = [START]
used = []

def solution(tickets):
    global used
    used = [False] * len(tickets)
    
    ### 백트래킹을 이용한 여행 경로 탐색
    useTicket(0, START, tickets)
    
    return answer

def useTicket(count, curr, tickets):
    global answer, route, used
    
    ### 현재 경로 route가 answer를 알파벳 순서로 앞설 수 없는 경우 early return
    if answer < route:
        return
    
    ### 모든 티켓을 다 사용한 경우 answer 갱신
    if count == len(tickets):
        answer = deepcopy(route)
        return
    
    for i in range(len(tickets)):
        if not used[i] and tickets[i][SRC] == curr:
            used[i] = True
            route.append(tickets[i][DEST])
            useTicket(count + 1, tickets[i][DEST], tickets)
            route.pop()
            used[i] = False
```

---

## ⏰ 복잡도
- 시간 복잡도: O(N!), N은 티켓의 개수
- 공간 복잡도: O(N)

---

## 📝 회고
- 조건을 만족하지 못하는 경우에는 `early return`하기
- 파이썬의 리스트는 `얕은 복사`가 기본이므로, 원본 리스트에 영향을 받지 않으려면 `deepcopy` 사용 필요