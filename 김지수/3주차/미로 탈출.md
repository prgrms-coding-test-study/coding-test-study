## ğŸ‘¤ ì‘ì„±ì
ê¹€ì§€ìˆ˜

---

## ğŸ§© ë¬¸ì œ ì •ë³´
<!-- [ë¬¸ì œ ì œëª©](ë¬¸ì œ ë§í¬) í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•˜ì„¸ìš” -->
[ë¯¸ë¡œ íƒˆì¶œ](https://school.programmers.co.kr/tryouts/198622/challenges)

---

## ğŸ’­ ì•„ì´ë””ì–´
- deque ê¸°ë°˜ ë„ˆë¹„ ìš°ì„  íƒìƒ‰ í™œìš©
- ë‘ ë²ˆì˜ ë„ˆë¹„ ìš°ì„  íƒìƒ‰ ìˆ˜í–‰
    1) ì‹œì‘ ì§€ì  -> ë ˆë²„
    2) ë ˆë²„ -> ì¶œêµ¬

---

## ğŸ§‘â€ğŸ’» ì½”ë“œ
<!-- ì‘ì„±í•œ ì½”ë“œë¥¼ ë°±í‹±ìœ¼ë¡œ ê°ì‹¸ ë„£ì–´ì£¼ì„¸ìš” --> 
```python
from collections import deque

INF = -1;

START = 'S';
EXIT = 'E';
LEVER = 'L';
WALL = 'X';

X = 0;
Y = 1;

### ìƒí•˜ì¢Œìš° ì´ë™
DIR = [[-1, 0], [1, 0], [0, -1], [0, 1]];

def solution(maps):   
    row = len(maps)
    col = len(maps[0])
    
    start = [];
    exit = [];
    lever = [];
    
    ### ë¯¸ë¡œ ìˆœíšŒ
    for i in range(row):
        for j in range(col):
            ### íŠ¹ìˆ˜ ì¢Œí‘œ ì €ì¥
            if maps[i][j] == START:
                start = [i, j];
            elif maps[i][j] == EXIT:
                exit = [i, j];
            elif maps[i][j] == LEVER:
                lever = [i, j];
    
    ### start -> lever ìµœì†Œ ì´ë™ ì‹œê°„ ê³„ì‚°
    first_result = move(maps, row, col, start, lever)
    
    if first_result == INF:
        return INF
    
    ### lever -> exit ìµœì†Œ ì´ë™ ì‹œê°„ ê³„ì‚°
    second_result = move(maps, row, col, lever, exit)
    
    if second_result == INF:
        return INF
    
    return first_result + second_result

def move(maps, row, col, src, dest) -> int:
    queue = deque()
    times = [[INF] * col for _ in range(row)]
    
    queue.append(src);
    times[src[X]][src[Y]] = 0;
    
    while queue:
        x, y = queue.popleft()
        
        if [x, y] == dest:
            return times[x][y]
        
        for dx, dy in DIR:
            nx = x + dx
            ny = y + dy
            
            if nx < 0 or nx >= row or ny < 0 or ny >= col:
                continue
            if times[nx][ny] != INF:
                continue
            if maps[nx][ny] == WALL:
                continue
            
            queue.append([nx, ny])
            times[nx][ny] = times[x][y] + 1
    
    return INF
```

---

## â° ë³µì¡ë„
- ì‹œê°„ ë³µì¡ë„: O(R * C)
- ê³µê°„ ë³µì¡ë„: O(R * C)

---

## ğŸ“ íšŒê³ 
- ë¬¸ì œì— ë”°ë¼ì„œ ë„ˆë¹„ ìš°ì„  íƒìƒ‰ì„ ë‘ ë²ˆ ì´ìƒ ìˆ˜í–‰í•  ìˆ˜ë„ ìˆìŒ
- ë°©ë¬¸ ì—¬ë¶€ ë¦¬ìŠ¤íŠ¸ ëŒ€ì‹  ìµœì†Œ ì‹œê°„ì„ ì €ì¥í•˜ëŠ” ë¦¬ìŠ¤íŠ¸ë¥¼ INF(-1)ë¡œ ì´ˆê¸°í™”í•´ì„œ ì‚¬ìš©