## ğŸ‘¤ ì‘ì„±ì
ê¹€ì§€ìˆ˜

---

## ğŸ§© ë¬¸ì œ ì •ë³´
<!-- [ë¬¸ì œ ì œëª©](ë¬¸ì œ ë§í¬) í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•˜ì„¸ìš” -->
[ì¹´ë“œ ë­‰ì¹˜](https://school.programmers.co.kr/tryouts/198619/challenges)

---

## ğŸ’­ ì•„ì´ë””ì–´
- deque ìë£Œêµ¬ì¡°ë¥¼ ì´ìš©í•œ í êµ¬í˜„
- ê° ì¹´ë“œ ë­‰ì¹˜ë¥¼ ë‘ ê°œì˜ íì— ì €ì¥
- ë‘ í ë¹„êµ í›„ ë‹¨ì–´ ì¶”ì¶œ

---

## ğŸ§‘â€ğŸ’» ì½”ë“œ
<!-- ì‘ì„±í•œ ì½”ë“œë¥¼ ë°±í‹±ìœ¼ë¡œ ê°ì‹¸ ë„£ì–´ì£¼ì„¸ìš” --> 
```python
from collections import deque

def solution(cards1, cards2, goal):
    goal_len = len(goal)
    goal_idx = 0  
    queue1 = deque(cards1)
    queue2 = deque(cards2)
    
    while queue1 and queue2 and goal_idx < goal_len:
        curr_goal = goal[goal_idx]
        card1 = queue1[0]
        card2 = queue2[0]
        
        if curr_goal == card1:
            queue1.popleft()
            goal_idx += 1
        elif curr_goal == card2:
            queue2.popleft()
            goal_idx += 1
        else: ### ë‘ ì¹´ë“œ ë­‰ì¹˜ë¥¼ ëª¨ë‘ ì‚¬ìš©í•´ë„ í˜„ì¬ ë‹¨ì–´ë¥¼ ë§Œë“¤ ìˆ˜ ì—†ëŠ” ê²½ìš° No ë°˜í™˜
            return "No"
    
    ### goalì„ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê²½ìš° Yes ë°˜í™˜
    if goal_idx == goal_len:
        return "Yes"
    
    ### ë‘ í ì¤‘ í•˜ë‚˜ë§Œ ë‚¨ì€ ê²½ìš°, ë‚¨ì€ ì¹´ë“œë¡œ goalì„ ë§Œë“¤ ìˆ˜ ìˆë‹¤ë©´ Yes ë°˜í™˜
    if queue1 and can_use_remaining_cards(queue1, goal, goal_idx):
        return "Yes"
    if queue2 and can_use_remaining_cards(queue2, goal, goal_idx):
        return "Yes"
    
    return "No"

def can_use_remaining_cards(queue, goal, goal_idx) -> bool:
    goal_len = len(goal)
    
    while queue and goal_idx < goal_len:
        if goal[goal_idx] != queue[0]:
            return False
        
        queue.popleft()
        goal_idx += 1
    
    return True
```

---

## â° ë³µì¡ë„
- ì‹œê°„ ë³µì¡ë„: O(N + M) -> N: ì „ì²´ ì¹´ë“œì˜ ê°œìˆ˜, M: goalì˜ ê¸¸ì´
- ê³µê°„ ë³µì¡ë„: O(N)

---

## ğŸ“ íšŒê³ 
- `deque(list)`ë¡œ ì´ˆê¸°í™” ê°€ëŠ¥ <-> C++ queue
- í•œ íì˜ ì¹´ë“œê°€ ë¨¼ì € ì†Œì§„ë˜ì—ˆì„ ë•Œ í›„ì²˜ë¦¬ ì£¼ì˜