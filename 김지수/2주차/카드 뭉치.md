## 👤 작성자
김지수

---

## 🧩 문제 정보
<!-- [문제 제목](문제 링크) 형식으로 작성하세요 -->
[카드 뭉치](https://school.programmers.co.kr/tryouts/198619/challenges)

---

## 💭 아이디어
- deque 자료구조를 이용한 큐 구현
- 각 카드 뭉치를 두 개의 큐에 저장
- 두 큐 비교 후 단어 추출

---

## 🧑‍💻 코드
<!-- 작성한 코드를 백틱으로 감싸 넣어주세요 --> 
```python
from collections import deque

def solution(cards1, cards2, goal):
    goal_len = len(goal)
    goal_idx = 0  
    queue1 = deque(cards1)
    queue2 = deque(cards2)
    
    while queue1 and queue2 and goal_idx < goal_len:
        curr_goal = goal[goal_idx]
        card1 = queue1[0]
        card2 = queue2[0]
        
        if curr_goal == card1:
            queue1.popleft()
            goal_idx += 1
        elif curr_goal == card2:
            queue2.popleft()
            goal_idx += 1
        else: ### 두 카드 뭉치를 모두 사용해도 현재 단어를 만들 수 없는 경우 No 반환
            return "No"
    
    ### goal을 만들 수 있는 경우 Yes 반환
    if goal_idx == goal_len:
        return "Yes"
    
    ### 두 큐 중 하나만 남은 경우, 남은 카드로 goal을 만들 수 있다면 Yes 반환
    if queue1 and can_use_remaining_cards(queue1, goal, goal_idx):
        return "Yes"
    if queue2 and can_use_remaining_cards(queue2, goal, goal_idx):
        return "Yes"
    
    return "No"

def can_use_remaining_cards(queue, goal, goal_idx) -> bool:
    goal_len = len(goal)
    
    while queue and goal_idx < goal_len:
        if goal[goal_idx] != queue[0]:
            return False
        
        queue.popleft()
        goal_idx += 1
    
    return True
```

---

## ⏰ 복잡도
- 시간 복잡도: O(N + M) -> N: 전체 카드의 개수, M: goal의 길이
- 공간 복잡도: O(N)

---

## 📝 회고
- `deque(list)`로 초기화 가능 <-> C++ queue
- 한 큐의 카드가 먼저 소진되었을 때 후처리 주의