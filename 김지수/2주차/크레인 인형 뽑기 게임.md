## π‘¤ μ‘μ„±μ
κΉ€μ§€μ

---

## π§© λ¬Έμ  μ •λ³΄
<!-- [λ¬Έμ  μ λ©](λ¬Έμ  λ§ν¬) ν•μ‹μΌλ΅ μ‘μ„±ν•μ„Έμ” -->
[ν¬λ μΈ μΈν• λ½‘κΈ° κ²μ„](https://school.programmers.co.kr/tryouts/198618/challenges)

---

## π’­ μ•„μ΄λ””μ–΄
- deque μλ£κµ¬μ΅°λ¥Ό μ΄μ©ν• μ¤νƒ κµ¬ν„
- μ—΄ λ‹¨μ„ μ¤νƒμ— μΈν• κ±°κΎΈλ΅ μ €μ¥ -> λ§¨ μ„ μΈν•λ¶€ν„° λ½‘κΈ° κ°€λ¥
- λ°”κµ¬λ‹ μƒλ‹¨μ— μ €μ¥λ μΈν•κ³Ό λ½‘ν μΈν•μ„ λΉ„κµν•μ—¬ μ—°μ†λ λ™μΌ μΈν• μ κ±°

---

## π§‘β€π’» μ½”λ“
<!-- μ‘μ„±ν• μ½”λ“λ¥Ό λ°±ν‹±μΌλ΅ κ°μ‹Έ λ„£μ–΄μ£Όμ„Έμ” --> 
```python
from collections import deque

def solution(board, moves):
    n = len(board)
    screen = [deque() for _ in range(n + 1)]
    basket = deque()
    answer = 0
    empty = 0
    top = -1
    
    ### κ²μ„ ν™”λ©΄ μ €μ¥
    for col in range(n):
        for row in range(n - 1, -1, -1): ### κ±°κΎΈλ΅ μνν•΄μ•Ό μΈν•μ„ λ§¨ μ„λ¶€ν„° μ κ±° κ°€λ¥
            if board[row][col] != empty:
                screen[col + 1].append(board[row][col])
    
    for move in moves:
        ### μΈν•μ΄ μ—†λ” κ³³μ—μ„ μΈν•μ„ λ½‘μΌλ ¤λ” κ²½μ° λ¬΄μ‹
        if not screen[move]:
            continue
        
        ### λ§¨ μ„ μΈν• λ½‘κΈ°
        doll = screen[move].pop()
        
        if not basket or basket[top] != doll:
            basket.append(doll)
        else: ### κ°™μ€ μΈν• λ‘ κ°κ°€ λ°”κµ¬λ‹μ— μ—°μ†ν•΄μ„ μ“μΈ κ²½μ°
            basket.pop()
            answer += 2 ### λ‘ μΈν• λ¨λ‘ μ κ±°
    
    return answer
```

---

## β° λ³µμ΅λ„
- μ‹κ°„ λ³µμ΅λ„: O(N^2 + M) -> N: boardμ ν¬κΈ°, M: movesμ κΈΈμ΄
- κ³µκ°„ λ³µμ΅λ„: O(N^2)

---

## π“ νκ³ 
- μ—΄ λ‹¨μ„ μ²λ¦¬ μ‹ μ΄μ¤‘ forλ¬Έμ μΈλ±μ¤ μμ„ μ£Όμ