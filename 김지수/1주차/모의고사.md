## 👤 작성자
김지수

---

## 🧩 문제 정보
<!-- [문제 제목](문제 링크) 형식으로 작성하세요 -->
[모의고사](https://school.programmers.co.kr/tryouts/198383/challenges)

---

## 💭 아이디어
- 일정한 패턴으로 문제를 찍기 때문에, 패턴을 리스트로 정의한 뒤 실제 정담과 비교해 점수 계산 -> 완전 탐색
- 반복되는 패턴은 인덱스 순환 처리

---

## 🧑‍💻 코드
<!-- 작성한 코드를 백틱으로 감싸 넣어주세요 --> 
```python
def solution(answers):
    first = [1, 2, 3, 4, 5]
    second = [2, 1, 2, 3, 2, 4, 2, 5]
    third = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]
    score = [0, 0, 0]
    
    ### score 리스트의 인덱스로 사용할 상수
    FIRST = 0
    SECOND = 1
    THIRD = 2
    
    for i in range(len(answers)):
        answer = answers[i]
        
        ### 점수 누적
        if first[i % len(first)] == answer:
            score[FIRST] += 1
        if second[i % len(second)] == answer:
            score[SECOND] += 1
        if third[i % len(third)] == answer:
            score[THIRD] += 1
    
    max_score = max(score)
    
    ### 가장 높은 점수를 받은 사람 저장
    ### 반복문에서 i가 오름차순으로 증가하므로 오름차순 정렬한 효과
    answer = [i + 1 for i in range(3) if score[i] == max_score] 
    
    return answer
```

---

## ⏰ 복잡도
- 시간 복잡도: O(N) -> N은 문제의 개수(`answers`의 길이)
- 공간 복잡도: O(1) -> 입력 크기에 비례하지 않음

---

## 📝 회고
- 리스트 컴프리헨션을 이용해 최대 점수를 받은 사람을 깔끔하게 구할 수 있음
- 반복되는 패턴은 인덱스 나머지 연산으로 처리 가능