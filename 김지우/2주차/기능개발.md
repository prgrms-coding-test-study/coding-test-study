
## 👤 작성자
김지우

---

## 🧩 문제 정보
<!-- [문제 제목](문제 링크) 형식으로 작성하세요 -->
[기능개발](https://school.programmers.co.kr/tryouts/198616/challenges)

---

## 💭 아이디어
- 문제에서 요구하는 조건 정리
- 해결을 위한 접근 방식
- 사용한 알고리즘 및 자료구조

- progresses, speeds가 주어짐. progresses는 현재 진행률, speeds는 1일에 진행되는 진척도
- 진척도가 100%가 되면 반영할 수 있는데, 이전 작업이 완료되어야 반영할 수 있음.
- 각 배포에 몇개의 기능이 배포되는지 리턴
- 1일마다 progresses를 순회하며 speeds만큼 값을 더함
- 100%가 되었을 경우 set에 추가
- 1일마다 순서대로 set에서 찾아 빼면서 숫자를 센다
---

## 🧑‍💻 코드
<!-- 작성한 코드를 백틱으로 감싸 넣어주세요 --> 
```python
def solution(progresses, speeds):
    answer = []
    # for문으로 얻은 progress를 수정해도 progresses에 반영되지 않음
    # 그래서 복사해 새로운 리스트 생성
    progressDiff = list(progresses)
    # 완료한 작업을 모아두는 set()
    completes = set()
    # 현재 마지막으로 완료된 작업 번호 
    lastCompleted = 0
    # 모든 작업이 완료될때까지 진행 
    while len(completes) < len(progresses):
        # 모든 progress를 순회하며 일일 작업도 추가
        for i, progress in enumerate(progresses):
            progressDiff[i]+=speeds[i]
            # 작업도가 100%가 되면 set에 추가
            if i not in completes and progressDiff[i] >= 100:
                completes.add(i)
        # 배포 작업 개수 카운터
        cnt = 0
        # 배포 가능한 작업들을 set에서 제거하면서 카운트
        while completes and lastCompleted in completes:
            completes.remove(lastCompleted)
            lastCompleted+=1
            cnt+=1
        # 결과에 카운트 추가
        if cnt > 0:
            answer.append(cnt)
    # print(completes)
    return answer
```

---

## ⏰ 복잡도
- 시간 복잡도: O(N^2)
- 공간 복잡도: O(N)

---

## 📝 회고
- 구현하며 어려웠던 점
- 실수한 부분
- 새롭게 공부한 내용

큐로 문제를 풀어보려고 시도했는데 해결방법을 몰라서 셋으로 해결함
