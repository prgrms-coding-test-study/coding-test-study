# 1. 파이선 List로큐를 구현할 때 pop(0)이 비효율적인 이유와, collections.deque의 popleft()가 효율적인 이유를 시간 복잡도 관점에서 설명하세요.

파이선 리스트는, 리스트 원소들의 포인터를 저장하는 배열으로 구현되어 있다. 그래서 0번째 인덱스를 삭제하면, 1번째부터 N번째 인덱스를 한칸씩 앞으로 당겨와야 한다.
그래서 pop(0)의 경우, O(N)의 시간복잡도를 가진다.
반면 deque는 큐의 구현처럼 앞,뒤 포인터를 이동시켜 데이터를 제거하고 추가할 수 있으므로 O(1)의 시간복잡도를 가진다.

# 2. 재귀 함수가 내부적으로 콜 스택을 사용하는 방식을 설명하고, RecursionError가 발생하는 이유를 설명하세요.
재귀 함수는 함수 내부에서 자기 자신을  호출한다.
함수를 호출할 때, 호출하기 이전의 컨텍스트를 스택에 저장하고, 재귀 호출한 함수가 종료되면 이 컨텍스트를 불러와 현재 상태를 복구한다.
재귀 함수 호출이 늘어날 수록, 저장해야 할 컨텍스트의 수가 증가해, 시스템에서 지정한 크기를 넘어가면 RecursionError가 발생한다.

# 3. 요세푸스 문제를 큐를 사용하여 해결하는 과정을 설명하고 ,큐가 문제에 적절한 자료구조인지 설명하세요
1부터 41의 숫자를 원형으로 배치하고, 1부터 시작해 다음 숫자로 넘어가며 숫자를 건너뛰고 다음 숫자를 제거하는 것을 반복해 마지막에 남는 숫자를 구하는 문제이다.

큐에 1~41을 넣고, 1을 빼고 다시 넣는다. 2는 뺀다. 3은 빼고 넣는다. 4 는 뺀다 ...
이것을 반복한다.

