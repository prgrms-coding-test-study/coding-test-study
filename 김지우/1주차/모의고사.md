
## 👤 작성자

김지우

---


## 🧩 문제 정보
<!-- [문제 제목](문제 링크) 형식으로 작성하세요 -->
[모의고사](https://www.acmicpc.net/problem/1234)

---

## 💭 아이디어
- 문제와 정답이 주어질 때, 입력 중 가장 많은 정답을 맞춘 사람을 출력
- 답을 찍는 방식이 패턴화 되어 있어서, 리스트에 저장하고 인덱스를 순회할 수 있음.
- 현재 문제가 n번 문제일 때, 다음 문제는 answers\[(n+1)%len(answers)\] 로 얻을 수 있음.
- 정답과 입력으로 얻은 답을 1개의 idx로 순회하면서 정답 갯수를 각각 세어 결과 리턴.
- 같은 횟수로 답을 맞춘 경우 오름차순 정렬해야 하는데, python3의 `from comptools import cmp_to_key` 를 이용해 복잡한 정렬을 `sort()`를 이용할 수 있음.

---

## 🧑‍💻 코드
<!-- 작성한 코드를 백틱으로 감싸 넣어주세요 --> 
```python
```python3
def solution(answers):
    
    student1 = [1,2,3,4,5]
    student2 = [2,1,2,3,2,4,2,5]
    student3 = [3,3,1,1,2,2,4,4,5,5]
    
    cnt1 = 0
    cnt2 = 0
    cnt3 = 0
    for i in range(len(answers)):
        answer = answers[i]
        ans1 = student1[i%len(student1)]
        ans2 = student2[i%len(student2)]
        ans3 = student3[i%len(student3)]
        if ans1 == answer:
            cnt1+=1
        if ans2 == answer:
            cnt2+=1
        if ans3 == answer:
            cnt3+=1
    answer = []
        
    tmp = [[1,cnt1],[2,cnt2],[3,cnt3]]
    tmp.sort(key=lambda x : x[1], reverse=True)
    tmpVal = tmp[0][1]
    for item in tmp:
        if tmpVal == item[1]:
            answer.append(item[0])
    
    return answer
```

---

## ⏰ 복잡도
- 시간 복잡도: O(n)
- 공간 복잡도: O(1)

---

## 📝 회고

<!-- - 구현하며 어려웠던 점 -->
<!-- - 실수한 부분 -->
<!-- - 새롭게 공부한 내용 -->
어렵지 않은 문제. 마지막에 중복시 오름차순 정렬에서 `sort()`의 `key` 파라미터를 람다 함수를 사용하여 작성하는 과정을 다시 상기했음.
