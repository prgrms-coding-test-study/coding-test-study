
## 👤 작성자

김지우

---

## 🧩 문제 정보
<!-- [문제 제목](문제 링크) 형식으로 작성하세요 -->
 [전화번호 목록](https://school.programmers.co.kr/learn/courses/30/lessons/42577)

---

## 💭 아이디어
<!-- - 문제에서 요구하는 조건 정리 -->
<!-- - 해결을 위한 접근 방식 -->
<!-- - 사용한 알고리즘 및 자료구조 -->
- 숫자로 이루어진 전화번호 스트링 리스트가 주어진다.
- 이때, 한 전화번호가 다른 전화번호의 접두사가 되는 경우, False, 그렇지 않은 경우 True를 리턴해야 한다.
- 브루트 포스로 문제를 해결하려는 경우, 1개의 문자열당 N-1번의 비교를 해야 하므로, O(N^2)의 시간복잡도가 걸린다. 이때 N이 10^6이므로, 이 방법으로 풀 수 없다.
- 한 문자열이 다른 문자열의 접두사가 되는지를O(1)에 비교하기 위해서, 딕셔너리를 사용할 수있다.
- 딕셔너리는 내부에서 해시 테이블로 작동하므로, 문자열을 1글자, 2글자, ... 로 자른 것을 key로 하고, 문자열 전체를 value로 하여 딕셔너리를 작성하면, 어떤 전화번호가 다른 전화번호의 접두사인지 비교할 때 O(1)안에 할 수 있다.
- 이때 주의할 점이 자기 자신을 Key로 하는 경우 ("0000":"0000")를 추가하면, 오답인 경우를 세게 된다.
- 조건에 같은 전화번호가 중복되어 들어있지 않다고 나오므로, 자기 자신을 key로 하는 경우만 빼고 딕셔너리에 추가하면 정답을 얻을 수 있다.
ex) \["0000", "0001"\]이 있다고 할때, 딕셔너리에 dict\["0000"\]를 넣으면 "0000"의 접두사로 "0000" 자신을 세기 때문에, 오답
dict\["000"\]를 넣으면 "0001"이 조건에 걸리고, "0000"은 걸리지 않으므로 해결.

---

## 🧑‍💻 코드
<!-- 작성한 코드를 백틱으로 감싸 넣어주세요 --> 
```python
def solution(phone_book):
    numDict = {}
  # 모든 번호를 조회
    for phone in phone_book:
    # 1글자부터 len(phone)-1글자까지 잘라 딕셔너리에 추가
        for i in range(1,len(phone)+1):
            splitted = phone[:i]
            if splitted not in numDict:
                numDict[splitted] = []
            numDict[splitted].append(phone)
    
  # dict 가 Key를 접두어로 하는 전화번호 리스트 이므로, 2개 이상의 전화번호가 포함된 경우 이 전화번호가 다른 전화번호의 접두어라고 볼 수 있다. 
    for key in numDict:
        if len(numDict[key])>1:
            return False
        
    return True
```

---

## ⏰ 복잡도
- 시간 복잡도: O(n)
- 공간 복잡도: O(n^2) -> 문자열 길이가 20이므로, 키는 최대 19개 생길 수 있음. 그리고 이 문자열이 n개가 있음. 그리고 느슨하게 최악의 경우를 가정해보면 어떤 문자열이 다른 모든 문자열의 접두어인 경우, 딕셔너리의 value값이 n-1인 리스트가 되므로 n-1. 그래소 19*n*(n-1)~=O(N^2)

---

## 📝 회고
<!-- - 구현하며 어려웠던 점 -->
<!-- - 실수한 부분 -->
<!-- - 새롭게 공부한 내용 -->
딕셔너리를 사용해서 순회 횟수를 줄이는 대표적인 방법.
set을 사용할 수도 있고, 여러가지 방법이 있을것 같다.
공간복잡도는 백트래킹같은 경우가 아니면 거의 고려하지 않는데, 공간복잡도가 커서 인풋이 크면 실패할 수 도?

