
## 👤 작성자

김지우

---

## 🧩 문제 정보
<!-- [문제 제목](문제 링크) 형식으로 작성하세요 -->
[실패율](https://school.programmers.co.kr/learn/courses/30/lessons/42889

---

## 💭 아이디어
<!-- - 문제에서 요구하는 조건 정리 -->
<!-- - 해결을 위한 접근 방식 -->
<!-- - 사용한 알고리즘 및 자료구조 -->
- 최대 도달 스테이지가 주어지면, 각 스테이지의 실패율을 구하는 문제
- `stages`를 내림차순 정렬하면, 스테이지에 도달한 총 인원수를 쉽게 구할 수 있음.
- \[2,1,2,6,2,4,3,3\] 일때, 오름차순 정렬하면 \[6,4,3,3,2,2,2,1\] 이고, 스테이지를 기준으로 5스테이지는 1명 도달, 4스테이지는 2명 도달, 3스테이지는 4명, 2스테이지는 7명, 1스테이지는 8명 도달했다.
1.  스테이지를 저장하는 변수를 가장 높은 스테이지로 초기화한다.(`curStage`)
2.  그리고 리스트를 순회하면서`curStage`와 리스트의 값을 비교해 리스트의 값이 작다면, 지금까지 지나쳐온 요소의 갯수만큼 해당 스테이지에 도달했다는 뜻이 된다.
예를 들어 curStage가 5이고, 리스트 순회하다가 4를 만난 경우, idx가 2이므로, 해당 스테이지 도달 숫자는 idx-1 = 1이 된다.
3. 그리고, `curStage`와 리스트의 값이 같은 경우는 해당 스테이지를 실패한 경우가 된다.
이 숫자를 `failCnt`로 저장한다.
4. 이제 2번 조건에 도달할 경우 `failCnt`/`curStage`로 실패율을 계산할 수 있다.
5. 실패율 계산이 끝나면, `curStage`를 현재 리스트의 값으로 수정한다.(5->4)
6. 이제 카운트 값을 초기화하고 계속 진행한다.

- 문제의 조건만이라면 스테이지당 도달 유저, 도달하고 실패한 유저를 각각 해쉬맵에 저장하여 계산하면 되지만, 스테이지의 갯수가  늘어날 수록, 어떤 유저가 높은 스테이지에 도달했다면, 1번 스테이지부터 N번 스테이지까지 카운트를 1씩 더해야 하기 때문에, 시간초과가 날 수 있다고 생각했음.


---

## 🧑‍💻 코드
<!-- 작성한 코드를 백틱으로 감싸 넣어주세요 --> 
```python
from functools import cmp_to_key

def comp(a, b):
    if a[1] > b[1]:
        return -1
    elif a[1] == b[1]:
        if a[0] < b[0]:
            return -1
        else:
            return 1
    else:
        return 1
            
    

def solution(N, stages):
    tmp = [] # 유저번호, 도달스테이지
    biggest = -1 # 최고 도전 스테이지
    # 최고 도달 스테이지와 stages에 유저 번호를 추가(유저 번호는 필요없)
    for i in range(len(stages)):
        stage = stages[i]
        tmp.append([i+1, stage])
        biggest = max(biggest, stage)
  # 스테이지 숫자순으로 오름차순 정렬
    tmp.sort(key=cmp_to_key(comp))
    # print(tmp)
  # 실패율 담을 리스트 
    failRate = [0]*(N+1)
    
    curStage = N
    failCnt = 0
    for i in range(len(tmp)):
      # curStage보다 작은 아이템을 만날때까지 전진
        if tmp[i][1] > curStage:
            continue
      # 만약 두 값이 같다면, 해당 스테이지에 도달했지만, 클리어하지 못한 경우.
        elif tmp[i][1] == curStage:
            failCnt+=1
            continue
      # curStage보다 작은 아이템을 만났다면, curStage에 도달하거나 도달해서 실패한 모든 아이템들이 조회되었다는 것임.
        else:
      # 만약 이 스테이지에 아무도 도달하지 못했을 경우라면 이전 스테이지로 넘어감.
            if i == 0:
                curStage-=1
                continue
        # 실패율을 계산해 저장하고 curStage와 failCnt를 초기화함. 
            else:
                failRate[curStage] = failCnt/i
                curStage = tmp[i]
                failCnt = 0
                if tmp[i][1] == curStage:
                    failCnt+=1
    # 순회가 끝나도 마지막 레벨의 경우 저장이 안되었으므로 이를 추가해 줘야 함.
    failRate[curStage] = failCnt/len(stages)
    # print(failRate)
    
    # failRate를 정답 포맷에 맞게 수정
    ans = [ [i, failRate[i]] for i in range(1, len(failRate))]
    # 이때 정답에서 같은실패율일 경우 스테이지 번호 기준 오름차순 정렬해야 하므로, 이를 정렬
    ans.sort(key = cmp_to_key(comp))
    
    # print(ans)
    
    answer = [item[0] for item in ans]
    return answer
```
---

## ⏰ 복잡도
- 시간 복잡도: O(n)
- 공간 복잡도: O(n)

---

## 📝 회고
<!-- - 구현하며 어려웠던 점 -->
<!-- - 실수한 부분 -->
<!-- - 새롭게 공부한 내용 -->
- 실패율을 계산하는 과정에서, 스테이지 범위나 N의 값이 아주 크다면, 대부분의 프로그래밍 언어에서 소수를 부동소수점으로 계산하므로, 아주 엣지 케이스에서는 이 소수의 대소 비교가 실패할수도 있지 않을까? 하는 생각을 함
- 원래라면 2개의 해시맵으로 인풋을 카운팅하면서 정렬해 결과를 작성했을 텐데, 갑자기 이 로직이 생각나서 풀게 되었음.
- comptools를 이용한 복잡한 정렬을 잘 할 수 있게 됨.

